((e,t)=>{'object'==typeof exports&&'undefined'!=typeof module?t(exports):'function'==typeof define&&define.amd?define(['exports'],t):t((e='undefined'!=typeof globalThis?globalThis:e||self).effector={})})(this,(e=>{function t(e,t){for(const r in e)t(e[r],r)}function r(e,t){e.forEach(t)}function n(e,t,r){if(!e)throw Error(`${r?r+': ':''}${t}`)}function a(e,t){const r=D(e),n=r.meta||{};X(e)||(n.isRegion=1),ue={id:r.id,parent:ue,value:e,template:n.template||pe(),sidRoot:n.sidRoot||ue&&ue.sidRoot,meta:n};try{return t()}finally{fe('region'),ue=P(ue)}}function o({node:e=[],from:t,source:n,parent:a=t||n,to:o,target:s,child:i=o||s,scope:c={},meta:l={},family:d={type:'regular'},regional:u}={}){const f=he(a),p=he(d.links),m=he(d.owners),g=[];r(e,(e=>e&&re(g,e)));const h={id:ce(),seq:g,next:he(i),meta:l,scope:c,family:{triggers:f.length,type:d.type||j,links:p,owners:m}};return r(p,(e=>re(F(e),h))),r(m,(e=>re(E(e),h))),r(f,(e=>re(e.next,h))),u&&ue&&ge(T(ue),[h]),h}function s(e,t,n){let a,o=Ye,s=null,i=Je;if(e.target&&(t=e.params,n=e.defer,a=e.meta,o='page'in e?e.page:o,e.stack&&(s=e.stack),i=V(e)||i,e=e.target),i&&Je&&i!==Je&&(Je=null),Array.isArray(e))for(let r=0;r<e.length;r++)We('pure',o,D(e[r]),s,t[r],i,a);else We('pure',o,D(e),s,t,i,a);if(n&&!Ke)return;const c={isRoot:Ke,currentPage:Ye,scope:Je,isWatch:Qe,isPure:Xe};let l,d,u,f,p,m;Ke=0;e:for(;f=Le();){const{idx:e,stack:t,type:n}=f;u=t.node,Ye=p=t.page,Je=V(t),p?m=p.reg:Je&&(m=Je.reg);const a=!!p,o=!!Je,s={fail:0,scope:u.scope};l=d=0;for(let r=e;r<u.seq.length&&!l;r++){const i=u.seq[r];if(i.order){const{priority:a,barrierID:o}=i.order,s=o?p?`${p.fullID}_${o}`:o:0;if(r!==e||n!==a){o?Ge.has(s)||(Ge.add(s),Ue(r,t,a,o)):Ue(r,t,a,0);continue e}o&&Ge.delete(s)}switch(i.type){case'mov':{const e=i.data;let r;switch(e.from){case'stack':r=T(t);break;case'a':case'b':r=t[e.from];break;case'value':r=e.store;break;case'store':if(m&&!m[e.store.id])if(a){const r=tt(p,e.store.id);t.page=p=r,r?m=r.reg:o?(ot(Je,e.store,0,1,e.softRead),m=Je.reg):m=void 0}else o&&ot(Je,e.store,0,1,e.softRead);r=Ee(m&&m[e.store.id]||e.store)}switch(e.to){case'stack':t.value=r;break;case'a':case'b':t[e.to]=r;break;case'store':rt(p,Je,e.target,0).current=r}break}case'compute':const e=i.data;if(e.fn){Qe='watch'===u.meta.op,Xe=e.pure;const r=e.safe?(0,e.fn)(T(t),s.scope,t):st(s,e.fn,t);e.filter?d=!r:t.value=r,Qe=c.isWatch,Xe=c.isPure}}l=s.fail||d}if(nt&&nt(t,s),!l){const e=T(t),n=V(t);if(r(u.next,(r=>{We('child',p,r,t,e,n)})),n){u.meta.needFxCounter&&We('child',p,n.fxCount,t,e,n),u.meta.storeChange&&We('child',p,n.storeChange,t,e,n),u.meta.warnSerialize&&We('child',p,n.warnSerializeNode,t,e,n);const a=n.additionalLinks[u.id];a&&r(a,(r=>{We('child',p,r,t,e,n)}))}}}Ke=c.isRoot,Ye=c.currentPage,Je=V(c)}function i(e,r="combine"){let n=r+'(',a='',o=0;return t(e,(e=>{o<25&&(null!=e&&(n+=a,n+=U(e)?W(e).fullName:e.toString()),o+=1,a=', ')})),n+')'}function c(e,t){let r,n;const a=e;if(t){const a=W(t);0===e.length?(r=a.path,n=a.fullName):(r=a.path.concat([e]),n=0===a.fullName.length?e:a.fullName+'/'+e)}else r=0===e.length?[]:[e],n=e;return{shortName:a,fullName:n,path:r}}function l(e,t){if(!t)return e;if(!t.name&&!t.named&&!t.loc)return e;let r=`[${e}]`;const n=t.named||t.name;n&&(r+=` unit '${n}'`);const a=t.loc;return!n&&a&&(r+=` (${a.file}:${a.line}:${a.column})`),r}function d(e,t){const r=t?e:e[0];ke(r);let n=r.or;const a=r.and;if(a){const r=t?a:a[0];if(ye(r)&&'and'in r){const r=d(a,t);e=r[0],n={...n,...r[1]}}else e=a}return[e,n]}function u(e){const t=()=>e();return t.unsubscribe=()=>e(),t}function f(e,...t){const r=pe();if(r){const n=r.handlers[e];if(n)return n(r,...t)}}function p(e,t){const r=ct({or:t,and:'string'==typeof e?{name:e}:e}),a=l('event',r),i=(e,...t)=>(n(!B(i,'derived'),'call of derived event is not supported, use createEvent instead',a),n(!Xe,'unit call from pure function is not supported, use operators like sample instead',a),Ye?((e,t,r,n)=>{const a=Ye;let o=null;if(t)for(o=Ye;o&&o.template!==t;)o=P(o);et(o);const s=e.create(r,n);return et(a),s})(i,c,e,t):i.create(e,t)),c=pe(),d=Object.assign(i,{graphite:o({meta:St(r.actualOp||z,i,r,kt(p)),regional:1}),create:e=>(s({target:i,params:e,scope:Je}),e),watch:e=>ht(i,e),map:e=>wt(i,C,e,[_e()]),filter:e=>wt(i,'filter',e.fn?e:e.fn,[_e(ze,1)]),filterMap:e=>wt(i,'filterMap',e,[_e(),Ce((e=>!ve(e)),1)]),prepend(e){n(i.targetable,'.prepend of derived event is not supported, call source event instead',a);const t=p('* \u2192 '+i.shortName,{parent:P(i)});return f('eventPrepend',D(t)),gt(t,i,[_e()],'prepend',e),bt(i,t),t}});return null!=r&&r.domain&&r.domain.hooks.event(d),L(d,'id',d.graphite.id),fe(d.graphite),d}function m(e,t,a,o,s){return we(a,`${s} ${t}`,'first argument'),n(be(o),'second argument should be a function',s),ne(!B(e,'derived'),`${t} in derived store`,`${t} in store created via createStore`,s),r(Array.isArray(a)?a:[a],(t=>{e.off(t),Mt(t,e,'on',xe,o)})),e}function g(e,t){const a=ct(t),i=Fe(e),c=l('store',a),d=p({named:'updates',derived:1});f('storeBase',i);const u=i.id,h='skipVoid'in a,y=h&&!a.skipVoid;ne(!(h&&a.skipVoid),'{skipVoid: true}','updateFilter',c);const b={updates:d,defaultState:e,stateRef:i,getState(){let e,t=i;if(Ye){let t=Ye;for(;t&&!t.reg[u];)t=P(t);t&&(e=t)}return!e&&Je&&(ot(Je,i,1),e=Je),e&&(t=e.reg[u]),Ee(t)},setState:e=>s({target:b,params:e,defer:1,scope:Je}),reset:(...e)=>(n(b.targetable,'.reset of derived store is not supported',c),r(e,(e=>m(b,'.reset',e,(()=>b.defaultState),c))),b),on:(e,t)=>(n(b.targetable,'.on of derived store is not supported',c),m(b,'.on',e,t,c)),off(e){const t=D(e).id,r=D(b).family.links.find((e=>e.meta.onTrigger===t));return r&&pt(r),b},map(e,t){let r,n;ye(e)&&(r=e,e=e.fn);const a=b.getState(),o=ve(a);pe()?n=null:(!o||o&&y)&&(n=e(a));const s=g(n,{name:`${b.shortName} \u2192 *`,derived:1,...t,and:r}),c=Mt(b,s,C,ze,e);return qe(q(s),{type:C,fn:e,from:i}),q(s).noInit=1,f('storeMap',i,c),s},watch(e,t){if(ne(!t,'watch second argument','sample',c),!t||!U(e)){const t=ht(b,e);return f('storeWatch',i,e)||e(b.getState()),t}return n(be(t),'second argument should be a function',c),e.watch((e=>t(b.getState(),e)))}},v=St(x,b,a,kt(g)),k=b.defaultConfig.updateFilter;b.graphite=o({scope:{state:i,fn:k},node:[Ce(((e,t,r)=>(r.scope&&!r.scope.reg[i.id]&&(r.b=1),e))),Ie(i),Ce(((e,t,{a:r,b:n})=>{const a=ve(e);return a&&!h&&ae(`${$t}`,b.graphite),(a&&y||!a)&&(e!==r||n)}),1),k&&_e(Me,1),Ae({from:I,target:i})],child:d,meta:{...v,defaultState:e,stateRef:i},regional:1}),L(b,'id',b.graphite.id),L(b,'rootStateRefId',u);const S=B(b,'serialize'),w=B(b,'derived'),$='ignore'===S,M=B(b,'sid');M&&(L(b,'storeChange',1),i.sid=M),M||$||w||L(b,'warnSerialize',1);const z=ve(e);return n(w||!z||z&&y,$t,c),w&&z&&!h&&console.error(`${c}: ${$t}`),ge(b,[d]),null!=a&&a.domain&&a.domain.hooks.store(b),w||(b.reinit=p({named:'reinit'}),b.reset(b.reinit)),i.meta=b.graphite.meta,fe(b.graphite),b}function h(...e){let t,r,a;[e,a]=d(e);const o=l('combine',a),s=e[e.length-1],i=e.length>1&&!G(s)&&ye(s),c=i&&s,u=i?e[e.length-2]:s;let f,p,m;if(be(u)?(r=e.slice(0,i?-2:-1),t=u):r=e,1===r.length){const e=r[0];G(e)||(f=e,p=1)}if(!p&&(f=r,t)){m=1;const e=t;t=t=>e(...t)}return n(ye(f),`${o}: shape should be an object`),xt(Array.isArray(f),!m,f,kt(h),a,t,c)}function y(){const e={};return e.req=new Promise(((t,r)=>{e.rs=t,e.rj=r})),e.req.catch((()=>{})),e}function b(e,t={}){const r=ct(be(e)?{handler:e}:e,t),a=l('effect',r),i=p(be(e)?{handler:e}:e,{...t,actualOp:N});vt(i,kt(b));const c=D(i);L(c,'op',i.kind=N),i.use=e=>(n(be(e),'.use argument should be a function',a),v.scope.handler=e,i),i.use.getCurrent=()=>v.scope.handler;const d=i.finally=p({named:'finally',derived:1}),u=i.done=d.filterMap({named:'done',fn({status:e,params:t,result:r}){if('done'===e)return{params:t,result:r}}}),f=i.fail=d.filterMap({named:'fail',fn({status:e,params:t,error:r}){if('fail'===e)return{params:t,error:r}}}),m=i.doneData=u.map({named:'doneData',fn:({result:e})=>e}),h=i.failData=f.map({named:'failData',fn:({error:e})=>e}),v=o({scope:{handler:i.defaultConfig.handler||(()=>n(0,`no handler used in ${i.compositeName.fullName}`))},node:[Ce(((e,t,r)=>{let n=t.handler;const a=V(r);if(a){const e=a.handlers.unitMap.get(i)||a.handlers.sidMap[i.sid];e&&(n=e)}return e.handler=n,e}),0,1),Ce(((e,t,r)=>{if(t.runnerFn&&!t.runnerFn(e,null,r))return;const{params:n,req:a,handler:o,args:s=[n]}=e,i=Nt(n,a,1,d,r),c=Nt(n,a,0,d,r),[l,u]=zt(o,c,s);l&&(ye(u)&&be(u.then)?u.then(i,c):i(u))}),0,1)],meta:{op:'fx',fx:'runner'},regional:1});c.scope.runner=v,re(c.seq,Ce(((e,{runner:t},r)=>{const n=P(r)?{params:e,req:{rs(e){},rj(e){}}}:e;return r.meta||(r.meta={fxID:le()}),s({target:t,params:n,defer:1,scope:V(r),meta:r.meta}),n.params}))),i.create=e=>{const t=y(),r={params:e,req:t};if(Je&&!Qe){const e=Je;t.req.finally((()=>{Ze(e)})).catch((()=>{}))}return s({target:i,params:r,scope:Je}),t.req};const k=i.inFlight=g(0,{serialize:'ignore',named:(B(i,'name')||i.graphite.id)+'.inFlight'}).on(i,(e=>e+1)).on(d,(e=>e-1)).map({fn:e=>e,named:'inFlight'});L(d,'needFxCounter','dec'),L(i,'needFxCounter',1);const S=i.pending=k.map({fn:e=>e>0,named:'pending'});return ge(i,[d,u,f,m,h,S,k]),null!=r&&r.domain&&r.domain.hooks.effect(i),i}function v(e,t){let a=0;return r(At,(r=>{r in e&&(n(null!=e[r],Ot(t,r)),a=1)})),a}function k(...e){let t,r,n,a,[[o,s,i],c]=d(e),u=1;const f=l('sample',c);return ve(s)&&ye(o)&&v(o,f)&&(s=o.clock,i=o.fn,'batch'in o?u=o.batch:(ne(!('greedy'in o),'greedy in sample','batch',f),u=!o.greedy),a=o.filter,t=o.target,r=o.name,n=o.sid,o=o.source),jt('sample',s,o,a,t,i,r,c,u,1,0,n)}function S(e,t,n){const a=[];(function e(o){ee(a,o)||(re(a,o),B(o,'op')===x&&(n||B(o,'sid'))&&t(o,B(o,'sid')),r(o.next,e),r(F(o),e),r(E(o),e))})(e)}function w(e,t){const a=Array.isArray(e)?new Map(e):e,o=new Map;let s=0;if(a instanceof Map){const e={};return r(a,((r,a)=>{n(U(a),'Map key should be a unit'),t&&t(a,r),a.sid&&(a.sid in e&&(s=1),e[a.sid]=r),o.set(a,r)})),{sidMap:e,unitMap:o,hasSidDoubles:s}}return{sidMap:a,unitMap:o}}function $(e,t){return G(t)?[De.mov({store:t.stateRef,to:'stack'}),...e]:e}const M='undefined'!=typeof Symbol&&Symbol.observable||'@@observable',x='store',z='event',N='effect',R='domain',A='scope',O='sampler',j='crosslink',C='map',I='stack',_='value',D=e=>e.graphite||e,F=e=>e.family.owners,E=e=>e.family.links,q=e=>e.stateRef,T=e=>e.value,P=e=>e.parent,V=e=>e.scope,B=(e,t)=>D(e).meta[t],L=(e,t,r)=>D(e).meta[t]=r,W=e=>e.compositeName,U=e=>(be(e)||ye(e))&&'kind'in e,H=e=>t=>U(t)&&t.kind===e,G=H(x),J=H(z),K=H(N),Q=e=>U(e)&&!!e.targetable,X=H(R),Y=H(A);var Z={__proto__:null,unit:U,store:G,event:J,effect:K,targetable:Q,domain:X,scope:Y,attached:e=>K(e)&&1==B(e,'attached')};const ee=(e,t)=>e.includes(t),te=(e,t)=>{const r=e.indexOf(t);-1!==r&&e.splice(r,1)},re=(e,t)=>e.push(t),ne=(e,t,r,n)=>!e&&console.error(`${n?n+': ':''}${t} is deprecated${r?`, use ${r} instead`:''}`),ae=(e,t)=>{const r=B(t,'unitTrace'),n=B(t,'config'),a=null!=n&&n.loc?` at ${n.loc.file}`:null,o=null==n?void 0:n.name;let s=e;o&&(s=`${o}: ${e}`),a&&(s=`${o}${a}: ${e}`);const i=Error(s);r&&(i.stack=r),r||o||a||console.log("Add effector's Babel or SWC plugin to your config for more detailed debug information or \"import \"effector/enable_debug_traces\" to your code entry module to see full stack traces"),console.error(i)},oe=()=>{let e=0;return()=>""+ ++e},se=oe(),ie=oe(),ce=oe(),le=oe();let de,ue=null;const fe=e=>{de&&de(e,ue)},pe=()=>ue&&ue.template,me=e=>(e&&ue&&ue.sidRoot&&(e=`${ue.sidRoot}|${e}`),e),ge=(e,t)=>{const n=D(e);r(t,(e=>{const t=D(e);n.family.type!==R&&(t.family.type=j),re(F(t),n),re(E(n),t)}))},he=(e=[])=>(Array.isArray(e)?e:[e]).flat().map(D),ye=e=>'object'==typeof e&&null!==e,be=e=>'function'==typeof e,ve=e=>void 0===e,ke=e=>n(ye(e)||be(e),'expect first argument be an object'),Se=(e,t,r,a)=>n(!(!ye(e)&&!be(e)||!('family'in e)&&!('graphite'in e)),`${t}: expect ${r} to be a unit (store, event or effect)${a}`),we=(e,t,n)=>{Array.isArray(e)?r(e,((e,r)=>Se(e,t,`${r} item of ${n}`,''))):Se(e,t,n,' or array of units')},$e=(e,t,a="target")=>r(he(t),(t=>n(!B(t,'derived'),`${e}: derived unit in "${a}" is not supported, use createStore/createEvent instead"`))),Me=(e,{fn:t},{a:r})=>t(e,r),xe=(e,{fn:t},{a:r})=>t(r,e),ze=(e,{fn:t})=>t(e),Ne=(e,t,r,n)=>{const a={id:ie(),type:e,data:t};return r&&(a.order={priority:r},n&&(a.order.barrierID=++Re)),a};let Re=0;const Ae=({from:e=x,store:t,target:r,to:n=(r?x:I),batch:a,priority:o})=>Ne('mov',{from:e,store:t,to:n,target:r},o,a),Oe=({fn:e,batch:t,priority:r,safe:n=0,filter:a=0,pure:o=0})=>Ne('compute',{fn:e,safe:n,filter:a,pure:o},r,t),je=({fn:e})=>Oe({fn:e,priority:N}),Ce=(e,t,r)=>Oe({fn:e,safe:1,filter:t,priority:r&&N}),Ie=(e,t,r)=>Ae({store:e,to:t?I:"a",priority:r&&O,batch:1}),_e=(e=ze,t)=>Oe({fn:e,pure:1,filter:t}),De={mov:Ae,compute:Oe,filter:({fn:e,pure:t})=>Oe({fn:e,filter:1,pure:t}),run:je},Fe=e=>({id:ie(),current:e,initial:e}),Ee=({current:e})=>e,qe=(e,t)=>{e.before||(e.before=[]),re(e.before,t)};let Te=null;const Pe=(e,t)=>{if(!e)return t;if(!t)return e;let r;return(e.v.type===t.v.type&&e.v.id>t.v.id||He(e.v.type)>He(t.v.type))&&(r=e,e=t,t=r),r=Pe(e.r,t),e.r=e.l,e.l=r,e},Ve=[];let Be=0;for(;Be<6;)re(Ve,{first:null,last:null,size:0}),Be+=1;const Le=()=>{for(let e=0;e<6;e++){const t=Ve[e];if(t.size>0){if(3===e||4===e){t.size-=1;const e=Te.v;return Te=Pe(Te.l,Te.r),e}1===t.size&&(t.last=null);const r=t.first;return t.first=r.r,t.size-=1,r.v}}},We=(e,t,r,n,a,o,s)=>Ue(0,{a:null,b:null,node:r,parent:n,value:a,page:t,scope:o,meta:s},e,0),Ue=(e,t,r,n)=>{const a=He(r),o=Ve[a],s={v:{idx:e,stack:t,type:r,id:n},l:null,r:null};3===a||4===a?Te=Pe(Te,s):(0===o.size?o.first=s:o.last.r=s,o.last=s),o.size+=1},He=e=>{switch(e){case'child':return 0;case'pure':return 1;case'read':return 2;case'barrier':return 3;case'sampler':return 4;case'effect':return 5;default:return-1}},Ge=new Set;let Je,Ke=1,Qe=0,Xe=0,Ye=null;const Ze=e=>{Je=e},et=e=>{Ye=e},tt=(e,t)=>{if(e){for(;e&&!e.reg[t];)e=e.parent;if(e)return e}return null},rt=(e,t,r,n)=>{const a=tt(e,r.id);return a?a.reg[r.id]:t?(ot(t,r,n),t.reg[r.id]):r};let nt;const at=e=>e,ot=(e,t,n,a,o)=>{const s=e.reg;if(s[t.id])return;const i=t.sid,c={id:t.id,current:t.initial,meta:t.meta};if(c.id in e.values.idMap)c.current=e.values.idMap[c.id];else if(i&&i in e.values.sidMap&&!(i in e.sidIdMap)){var l;const r=null==t||null===(l=t.meta)||void 0===l?void 0:l.serialize;c.current=(e.fromSerialize&&'ignore'!==r&&(null==r?void 0:r.read)||at)(e.values.sidMap[i])}else if(t.before&&!o){let o=0;const i=n||!t.noInit||a;r(t.before,(t=>{switch(t.type){case'map':{const r=t.from;if((r||t.fn)&&(r&&ot(e,r,n,a),i)){const e=r&&s[r.id].current;c.current=t.fn?t.fn(e):e}break}case'field':ot(e,t.from,n,a),o||(o=1,c.current=Array.isArray(c.current)?[...c.current]:{...c.current}),i&&(c.current[t.field]=s[s[t.from.id].id].current)}}))}i&&(e.sidIdMap[i]=t.id),s[t.id]=c},st=(e,t,r)=>{try{return t(T(r),e.scope,r)}catch(t){console.error(t),e.fail=1,e.failReason=t}},ct=(e,r={})=>(ye(e)&&(ct(e.or,r),t(e,((e,t)=>{ve(e)||'or'===t||'and'===t||(r[t]=e)})),ct(e.and,r)),r),lt=(e,t)=>{te(e.next,t),te(F(e),t),te(E(e),t)},dt=['on','reset','sample','split','merge','guard','forward'],ut=(e,t,r,n,a)=>{let o;e.next.length=0,e.seq.length=0,e.scope=null;let s=E(e);const{stateRef:i,defaultShape:c,isRegion:l,op:d}=e.meta;if(i&&(i.before=[],e.meta.stateRef=null),c)for(const e in c)c[e]=null;const u=l?e:n;if(s.length>0){const n=ee(dt,d),i=!l&&!a,c=i&&r&&!n;for(;o=s.pop();){const s=ee(o.next,e);lt(o,e),l&&ut(o,0,0,e,1),s||(o.family.triggers-=1),(t||c||i&&o.family.type===j&&!n||a&&ee(dt,o.meta.op)&&(s&&0===o.next.length||!s&&o.family.triggers<=0))&&ut(o,t,r&&'on'!==o.meta.op,u,a)}}for(s=F(e);o=s.pop();)lt(o,e),r&&o.family.type===j&&ut(o,t,'on'!==o.meta.op,u,a)},ft=e=>e.clear(),pt=(e,{deep:t}={})=>{let r=0;if(e.ownerSet&&e.ownerSet.delete(e),X(e)){r=1;const t=e.history;ft(t.events),ft(t.effects),ft(t.stores),ft(t.domains)}ut(D(e),!!t,r,null,0)},mt=e=>u((()=>pt(e))),gt=(e,t,r,n,a)=>o({node:r,parent:e,child:t,scope:{fn:a},meta:{op:n},family:{owners:[e,t],links:t},regional:1}),ht=(e,t)=>(n(be(t),'.watch argument should be a function'),mt(o({scope:{fn:t},node:[je({fn:ze})],parent:e,meta:{op:'watch'},family:{owners:e},regional:1})));let yt=0;const bt=(e,t,r=z)=>{P(e)&&P(e).hooks[r](t)},vt=(e,t)=>L(e,'unitTrace',t),kt=e=>{if(!(()=>yt)())return'';const t=Error('unit trace');return Error.captureStackTrace&&Error.captureStackTrace(t,e),t.stack},St=(e,t,r,n)=>{const a=ct(r),o=e===R,s=se(),{sid:i=null,named:l=null,domain:d=null,parent:u=d}=a,f=l||a.name||(o?'':s),p=c(f,u),m={op:t.kind=e,name:t.shortName=f,sid:t.sid=me(i),named:l,unitId:t.id=s,serialize:a.serialize,derived:a.derived,config:a,unitTrace:n};if(t.targetable=!a.derived,t.parent=u,t.compositeName=p,t.defaultConfig=a,t.getType=()=>(ne(0,'getType','compositeName.fullName'),p.fullName),!o){t.subscribe=e=>(ke(e),t.watch(be(e)?e:t=>e.next&&e.next(t))),t[M]=()=>t;const e=pe();e&&(m.nativeTemplate=e)}return m},wt=(e,t,r,n)=>{let a;ye(r)&&(a=r,r=r.fn);const o=p({name:`${e.shortName} \u2192 *`,derived:1,and:a});return gt(e,o,n,t,r),o},$t='undefined is used to skip updates. To allow undefined as a value provide explicit { skipVoid: false } option',Mt=(e,t,r,n,a)=>{const o=q(t),s=Ae({store:o,to:"a",priority:'read'});r===C&&(s.data.softRead=1);const i=[s,_e(n)];f('storeOnMap',o,i,G(e)&&q(e));const c=gt(e,t,i,r,a);return r!==C&&L(c,'onTrigger',D(e).id),c},xt=(e,r,a,s,c,d,u)=>{const p=l('combine',c),m=e?e=>[...e]:e=>({...e}),h=e?[]:{},y=m(h),b=Fe(y),v=Fe(1);b.type=e?'list':'shape',b.noInit=1,f('combineBase',b,v);const k=g(y,{name:i(a),derived:1,...u,and:c});vt(k,s);const S=q(k);S.noInit=1,L(k,'isCombine',1),ge(k,[o({meta:{stateRef:b}})]);const w=Ie(b);w.order={priority:'barrier'};const $=Ae({store:S,to:'b',priority:'read'});$.data.softRead=1;const M=[Ce(((e,t,r)=>(r.scope&&!r.scope.reg[b.id]&&(r.c=1),e))),w,Ae({store:v,to:'b'}),Ce(((e,{key:t},n)=>{if(n.c||e!==n.a[t])return r&&n.b&&(n.a=m(n.a)),n.a[t]=e,1}),1),Ae({from:"a",target:b}),Ae({from:_,store:0,target:v}),Ae({from:_,store:1,target:v,priority:'barrier',batch:1}),Ie(b,1,1),d&&_e(),$];if(t(a,((e,t)=>{if(!G(e))return n(!U(e)&&!ve(e),`combine expects a store in a field ${t}`,p),void(y[t]=h[t]=e);h[t]=e.defaultState,y[t]=e.getState();const r=gt(e,k,M,'combine',d);r.scope.key=t;const a=q(e);qe(b,{type:'field',field:t,from:a}),f('combineField',a,r)})),k.defaultShape=a,L(k,'defaultShape',a),qe(S,{type:C,from:b,fn:d}),!pe())if(d){const e=d(y);!ve(e)||u&&'skipVoid'in u||console.error(`${p}: ${$t}`),S.current=e,S.initial=e,k.defaultState=e}else k.defaultState=h;return k},zt=(e,t,r)=>{try{return[1,e(...r)]}catch(e){return t(e),[0,null]}},Nt=(e,t,r,n,a)=>o=>{s({target:[n,Rt],params:[r?{status:'done',params:e,result:o}:{status:'fail',params:e,error:o},{value:o,fn:r?t.rs:t.rj}],defer:1,page:a.page,scope:a.scope,meta:a.meta})},Rt=o({node:[je({fn:({fn:e,value:t})=>e(t)})],meta:{op:'fx',fx:'sidechain'}}),At=['source','clock','target'],Ot=(e,t)=>e+`: ${t} should be defined`,jt=(e,t,r,a,o,s,i,c,d,u,m,y)=>{const b=l(e,c),v=!!o;n(!ve(r)||!ve(t),Ot(b,'either source or clock'));let S=0;ve(r)?S=1:U(r)||(r=h(r)),ve(t)?t=r:(we(t,b,'clock'),Array.isArray(t)&&(t=gt(t,[],[],e))),S&&(r=t),c||i?c&&i?c.name=i:!c&&i&&(c={name:i}):i=r.shortName;let w='none';(m||a)&&(U(a)?w='unit':(n(be(a),'`filter` should be function or unit'),w='fn')),o?(we(o,b,'target'),$e(b,o)):'none'===w&&u&&G(r)&&G(t)?o=g(s?s(Ee(q(r)),Ee(q(t))):Ee(q(r)),{name:i,sid:y,or:c}):(o=p({name:i,derived:1,or:c}),f('sampleTarget',D(o)));const $=Fe();let M=[];const x=[];if('unit'===w){const[r,n,s,i]=It(a,o,t,$,e);i&&re(x,i),s||M.push(...Ct(n)),M.push(...Ct(r))}const z=[];if(S)d&&re(z,Ie($,1,1));else{const[n,a,s,i]=It(r,o,t,$,e);i&&re(x,i),s||z.push(...Ct(a)),re(z,Ie(n,1,d))}const N=gt(t,o,[f('sampleSourceLoader'),Ae({from:I,target:$}),...z,...M,Ie($),'fn'===w&&_e(((e,t,{a:r})=>a(e,r)),1),s&&_e(Me),f('sampleSourceUpward',v)],e,s);return ge(r,[N]),ge(N,x),Object.assign(N.meta,c,{joint:1,stateRef:$}),vt(N,kt(k)),o},Ct=e=>[Ie(e),Ce(((e,t,{a:r})=>r),1)],It=(e,t,r,n,a)=>{const s=G(e),i=s?q(e):Fe(),c=Fe(s);let l;return s||(l=o({parent:e,node:[Ae({from:I,target:i}),Ae({from:_,store:1,target:c})],family:{owners:[...new Set([e,t,r].flat())],links:t},meta:{op:a},regional:1})),f('sampleSource',c,i,n),[i,c,s,l]},_t=(e,t,r,n)=>{const a=e[t];a&&s({target:a,params:Array.isArray(a)?a.map((()=>r)):r,defer:1,stack:n})},Dt=e=>!e.node.meta.isCombine||e.parent&&'combine'!==e.parent.node.meta.op,Ft=e=>e;e.PRIVATE_API_DO_NOT_TOUCH_NO_SEMVER_SUPPORT={setDebugTraces:e=>{yt=e,e&&console.log("[effector/debug_traces] Debug traces enabled")}},e.allSettled=(e,{scope:t,params:r}={})=>{if(!U(e))return Promise.reject(new Error('first argument should be unit'));if(!(K(e)||J(e)||G(e)||Y(e)))return Promise.reject(new Error('first argument accepts only effects, events, stores or scopes'));if(Y(e))t=e;else if(!Q(e)){const t=l('allSettled',D(e).meta);return Promise.reject(Error(`${t}: unit should be targetable`))}const n=y();n.parentFork=Je;const{fxCount:a}=t;re(a.scope.defers,n);const o=[],i=[];return Y(e)||(re(o,e),re(i,K(e)?{params:r,req:{rs(e){n.value={status:'done',value:e}},rj(e){n.value={status:'fail',value:e}}}}:r)),re(o,a),re(i,null),s({target:o,params:i,scope:t}),n.req},e.attach=function e(t){let r;[t,r]=d(t,1);const a=l('attach',r);let{source:o,effect:i,mapParams:u,domain:f}=t;K(i)&&n(ve(f),'`domain` can only be used with a plain function',a);const p=b(t,r);L(p,'attached',1),vt(p,kt(e));const{runner:m}=D(p).scope;let g;const y=(e,t,r)=>{const{params:n,req:a,handler:i}=e,c=p.finally,l=Nt(n,a,0,c,r),d=r.a,f=K(i);let m,g=1;if(u?[g,m]=zt(u,l,[n,d]):m=o&&f?d:n,g){if(!f)return e.args=[d,m],1;s({target:i,params:{params:m,req:{rs:Nt(n,a,1,c,r),rj:l}},page:r.page,defer:1,meta:r.meta})}};if(o){let e;m.scope.runnerFn=y,G(o)?(e=o,ge(e,[p])):(e=h(o),ge(p,[e])),g=[Ce((e=>e),0,1),Ie(q(e))],delete m.seq[1].order}else g=[Ce(y,1,1)];m.seq.splice(1,0,...g),p.use(i);const v=P(i);return v&&(Object.assign(W(p),c(p.shortName,v)),p.defaultConfig.parent=v),bt(i,p,N),p},e.clearNode=pt,e.combine=h,e.createApi=(...e)=>{let[[r,n],a]=d(e);const o={};return t(n,((e,t)=>{const n=o[t]=p(t,{parent:P(r),config:a});r.on(n,e),bt(r,n)})),o},e.createDomain=function e(n,a){const i=ct({or:a,and:'string'==typeof n?{name:n}:n}),c=o({family:{type:R},regional:1,parent:(null==i?void 0:i.domain)||(null==i?void 0:i.parent)}),l={history:{},graphite:c,hooks:{}};c.meta=St(R,l,{parent:(null==i?void 0:i.domain)||(null==i?void 0:i.parent),or:{...i,derived:1}},kt(e)),t({Event:p,Effect:b,Store:g,Domain:e},((e,t)=>{const n=t.toLowerCase(),a=(e=>p({named:e}))(`on${t}`);l.hooks[n]=a;const o=new Set;l.history[`${n}s`]=o,a.create=e=>(s(a,e),e),re(D(a).seq,Ce(((e,t,r)=>(r.scope=null,e)))),a.watch((e=>{ge(l,[e]),o.add(e),e.ownerSet||(e.ownerSet=o),P(e)||(e.parent=l)})),ge(l,[a]),l[`onCreate${t}`]=e=>(r(o,e),a.watch(e)),l[`create${t}`]=l[n]=(t,r)=>{const n=ct({and:r,or:t});return null!=n&&n.domain?e(t,r):a(e(t,{parent:l,or:n}))}}));const d=P(l);return d&&t(l.hooks,((e,t)=>gt(e,d.hooks[t]))),null!=i&&i.domain&&i.domain.hooks.domain(l),l},e.createEffect=b,e.createEvent=p,e.createNode=o,e.createStore=g,e.createWatch=({unit:e,fn:t,scope:r,batch:n})=>{const a=[De.run({fn:e=>t(e)})];n&&a.unshift(De.compute({priority:'sampler',batch:1})),G(e)&&a.unshift(De.mov({store:e.stateRef,to:'stack'}));const s=Array.isArray(e)?e:[e];if(r){const e=[],t=r.additionalLinks;return s.forEach((r=>{const n=t[r.graphite.id]||[];t[r.graphite.id]=n;const s=o({node:$(a,r),meta:{watchOp:r.kind}});n.push(s),e.push((()=>{const e=n.indexOf(s);-1!==e&&n.splice(e,1),pt(s)}))})),u((()=>{e.forEach((e=>e()))}))}{const e=o({node:a,parent:s,family:{owners:s}});return u((()=>{pt(e)}))}},e.fork=(e,t)=>{let a,s=e;X(e)&&(ne(0,'fork(domain)','fork()'),a=e,s=t);const i=(e=>{const t=o({scope:{defers:[],inFlight:0,fxID:0},node:[Ce(((e,t,r)=>{r.parent?'dec'===r.parent.node.meta.needFxCounter?t.inFlight-=1:(t.inFlight+=1,t.fxID+=1):t.fxID+=1})),Oe({priority:O,batch:1}),Ce(((e,t)=>{const{defers:n,fxID:a}=t;t.inFlight>0||0===n.length||Promise.resolve().then((()=>{t.fxID===a&&r(n.splice(0,n.length),(e=>{Ze(e.parentFork),e.rs(e.value)}))}))}),0,1)]}),n=o({node:[Ce(((e,t,r)=>{const n=r.parent;if(n){const t=n.node;if(Dt(n)){const n=V(r),a=t.meta.sid;n.sidIdMap[a]=t.scope.state.id,n.values.sidMap[a]=e;const o=t.meta.serialize;o&&n.sidSerializeSettings.set(a,'ignore'===o?{ignore:1}:{ignore:0,write:o.write})}}}))]}),a=o({node:[Ce(((e,t,r)=>{const n=V(r),a=r.parent;n&&a&&Dt(a)&&n.warnSerializeNodes.add(a.node)}))]}),s={cloneOf:e,reg:{},values:{sidMap:{},idMap:{}},sidIdMap:{},sidSerializeSettings:new Map,getState(e){if('current'in e)return rt(Ye,s,e,0).current;const t=D(e);return rt(Ye,s,t.scope.state,1).current},kind:A,graphite:o({family:{type:R,links:[t,n,a]},meta:{unit:'fork'},scope:{forkInFlightCounter:t}}),additionalLinks:{},handlers:{sidMap:{},unitMap:new Map},fxCount:t,storeChange:n,warnSerializeNodes:new Set,warnSerializeNode:a};return s})(a);if(s){if(s.values){const{sidMap:e,unitMap:t,hasSidDoubles:a}=w(s.values,(e=>n(G(e)&&Q(e),'Values map can contain only writable stores as keys')));Object.assign(i.values.sidMap,e),r(t,((e,t)=>{if(i.values.idMap[t.stateRef.id]=e,i.sidIdMap[B(t,'sid')]=t.stateRef.id,'ignore'===B(t,'serialize')){const e=B(t,'sid');i.sidSerializeSettings.set(e,{ignore:1})}})),i.fromSerialize=!(Array.isArray(s.values)||s.values instanceof Map),i.hasSidDoubles=a}s.handlers&&(ne(s.handlers instanceof Map||Array.isArray(s.handlers),'object with handlers','array'),i.handlers=w(s.handlers,(e=>n(K(e),"Handlers map can contain only effects as keys"))))}return i},e.forward=e=>{const t='forward',[{from:r,to:n},a]=d(e,1),s=l(t,a);return ne(0,t,'sample',s),we(r,s,'"from"'),we(n,s,'"to"'),$e(s,n,'to'),mt(o({parent:r,child:n,meta:{op:t,config:a},family:{},regional:1}))},e.fromObservable=e=>{ke(e);const t=M in e?e[M]():e;n(t.subscribe,'expect observable to have .subscribe');const r=p(),a=mt(r);return t.subscribe({next:r,error:a,complete:a}),r},e.guard=(...e)=>{let[[t,r],n]=d(e);const a=l('guard',n);return ne(0,'guard','sample',a),r||(r=t,t=r.source),v(r,a),jt('guard',r.clock,t,r.filter,r.target,null,r.name,n,!r.greedy,0,1)},e.hydrate=(e,{values:t})=>{n(ye(t),'values property should be an object');const{sidMap:a,unitMap:o}=w(t),i=Object.getOwnPropertyNames(a),c={};r(o,((e,t)=>{c[t.stateRef.id]=t}));const l=[],d=[];let u,f,p;Y(e)?(u=e,p=1,n(u.cloneOf,'scope should be created from domain'),ne(0,'hydrate(fork(domain), { values })','fork({ values })'),f=D(u.cloneOf)):X(e)?(ne(0,'hydrate(domain, { values })','fork({ values })'),f=D(e)):n(0,'first argument of hydrate should be domain or scope'),S(f,((e,t)=>{if(t&&ee(i,t)){re(l,e);const r=B(e,'serialize');r&&'ignore'!==r&&(a[t]=r.read(a[t])),re(d,a[t])}else e.scope.state.id in c&&(re(l,e),re(d,o.get(c[e.scope.state.id])))}),1),s({target:l,params:d,scope:u}),p&&Object.assign(u.values.sidMap,a)},e.is=Z,e.launch=s,e.merge=(e,t)=>{const r=l('merge',t);we(e,r,'first argument');const n=p({name:i(e,'merge'),derived:1,and:t});return gt(e,n,[],'merge'),n},e.restore=(e,r,a)=>{const o=l('restore',a);if(n(!G(e),'restore($store) is not supported',o),J(e)||K(e)){const t=P(e),n=g(r,{parent:t,name:e.shortName,and:a});return gt(K(e)?e.doneData:e,n),t&&t.hooks.store(n),n}const s=Array.isArray(e)?[]:{};return t(e,((e,t)=>s[t]=G(e)?e:g(e,{name:t}))),s},e.sample=k,e.scopeBind=(e,{scope:t,safe:r}={})=>{n(t||Je||r,'scopeBind: scope not found');const a=t||Je;return(...t)=>{function r(){Ze(s)}let n,o=0;const s=Je;Ze(a);try{n=e(...t)}catch(e){n=e,o=1}if(r(),o)throw n;return n instanceof Promise&&n.then(r,r),n}},e.serialize=(e,a={})=>{e.warnSerializeNodes.size&&(console.error('serialize: One or more stores dont have sids, their values are omitted'),r(e.warnSerializeNodes,(e=>{ae('store should have sid or `serialize: ignore`',e)}))),n(!e.hasSidDoubles,'duplicate sid found in this scope');const o=a.ignore?a.ignore.map((({sid:e})=>e)):[],s={};return t(e.values.sidMap,((t,r)=>{var n;if(ee(o,r))return;const a=e.sidIdMap[r],i=null!==(n=e.sidSerializeSettings.get(r))&&void 0!==n?n:{ignore:0,write:Ft};i.ignore||(s[r]=(0,i.write)(a&&a in e.reg?e.reg[a].current:t))})),'onlyChanges'in a&&(ne(0,'onlyChanges'),a.onlyChanges||(n(e.cloneOf,'scope should be created from domain'),S(D(e.cloneOf),((t,r)=>{r in s||ee(o,r)||B(t,'isCombine')||'ignore'===B(t,'serialize')||(s[r]=e.getState(t))})))),s},e.setGraphInspector=e=>{de=e},e.setInspector=e=>{nt=e},e.setStoreName=(e,t)=>{e.shortName=t,Object.assign(W(e),c(t,P(e)))},e.split=function e(...r){const a='split';let s,i,[[c,u],m]=d(r);const g=l(a,m),h=!u;h&&(s=c.cases,u=c.match,i=c.clock,c=c.source);const y=G(u),b=!U(u)&&be(u),v=!y&&!b&&ye(u);n(U(c),'source must be a unit',g),s||(s={}),h?t(s,((e,t)=>$e(g,e,`cases.${t}`))):(n(v,'match should be an object',g),t(u,((e,t)=>s[t]=p({derived:1,named:`cases.${t}`,and:m}))),s.__=p({derived:1,named:'cases.__',and:m}));const k=new Set([].concat(c,i||[],Object.values(s))),S=Object.keys(y||b?s:u);let w,$;if(y||b)y&&k.add(u),w=[y&&Ie(q(u),0,1),Oe({safe:y,filter:1,pure:!y,fn(e,t,r){const n=String(y?r.a:u(e));_t(t,ee(S,n)?n:'__',e,r)}})];else if(v){const e=$=Fe({});e.type='shape';const r=[];let n;t(u,((t,a)=>{if(U(t)){n=1,re(r,a),k.add(t);const o=gt(t,[],[Ie(e),Ce(((e,t,{a:r})=>r[a]=e))]);if(G(t)){e.current[a]=t.getState();const r=q(t);qe(e,{from:r,field:a,type:'field'}),f('splitMatchStore',r,o)}}})),n&&f('splitBase',e),w=[n&&Ie(e,0,1),_e(((e,t,n)=>{for(let a=0;a<S.length;a++){const o=S[a];if(ee(r,o)?n.a[o]:u[o](e))return void _t(t,o,e,n)}_t(t,'__',e,n)}),1)]}else n(0,'expect match to be unit, function or object');const M=o({meta:{op:a,stateRef:$},parent:i?[]:c,scope:s,node:w,family:{owners:Array.from(k)},regional:1});if(i&&jt(a,i,c,null,M,null,a,m,0,0,0),vt(M,kt(e)),!h)return s},e.step=De,e.version="23.4.2",e.withFactory=({sid:e,name:t,loc:r,method:n,fn:s})=>a(o({meta:{sidRoot:me(e),sid:e,name:t,loc:r,method:n,type:'factory'},regional:1}),s),e.withRegion=a,Object.defineProperty(e,'__esModule',{value:1})}));
//# sourceMappingURL=effector.umd.js.map
